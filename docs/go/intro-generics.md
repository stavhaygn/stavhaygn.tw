---
sidebar_position: 4
---

# [go.dev] 介紹泛型

> 非原創內容，來源為 Robert Griesemer 與 Ian Lance Taylor 於 2022 年 3 月 22 日的文章 [An Introduction To Generics](https://go.dev/blog/intro-generics)，如有版權問題，請告知，將會立即刪除。

## 介紹

Go 1.18 版本新增了對泛型的支援。泛型是自從第一個開源版本以來，我們對 Go 所做的最大改變。在本文中，我們將介紹新的語言功能。我們不會試圖涵蓋所有細節，但我們會觸及所有重要的點。有關更詳細和更長的說明，包括許多示例，請參閱[提案文件](https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md)。有關語言更改的更精確描述，請參閱[更新的語言規範](https://go.dev/ref/spec)。（請注意，實際的 1.18 實現對提案文件允許的內容施加了一些限制；規範應該是準確的。未來的版本可能會解除某些限制。）

泛型是一種撰寫與正在使用的特定型別無關的程式碼的方法。現在可以撰寫函數和型別來使用任何一組型別。

泛型為語言增加了三個新的大功能：

- 函數和型別的型別參數。
- 將介面型別定義為型別集，包括沒有方法的型別。
- 型別推斷，允許在許多情況下在呼叫函數時省略型別參數。

## 型別參數

函數和型別現在允許有型別參數。型別參數列表看起來像一般的參數列表，只是它使用方括號而不是圓括號。

To show how this works, let’s start with the basic non-generic Min function for floating point values:

為了展示這是如何運作的，讓我們從基本的非泛型 Min 函數開始，用於浮點值：

```go
func Min(x, y float64) float64 {
    if x < y {
        return x
    }
    return y
}
```

我們可以通過添加型別參數列表來使此函數成為泛型，使其適用於不同的型別。在此範例中，我們添加了一個帶有單個型別參數 T 的型別參數列表，並將 float64 的使用替換為 T。

```go
import "golang.org/x/exp/constraints"

func GMin[T constraints.Ordered](x, y T) T {
    if x < y {
        return x
    }
    return y
}
```

現在可以通過撰寫像這樣的方式來使用型別引數呼叫此函數

```go
x := GMin[int](3, 4)
```

提供型別引數給 GMin，例如 int，稱為實例化。實例化分為兩個步驟。首先，編譯器會在整個泛型函數或型別中將所有型別引數替換為其各自的型別參數。其次，編譯器會驗證每個型別引數是否滿足各自的約束。我們很快就會知道這是什麼意思，但如果第二步失敗，實例化將失敗，並且程式無效。

實例化成功後，我們有一個非泛型函數，可以像任何其他函數一樣呼叫。例如，在像這樣的程式碼中

```go
fmin := GMin[float64]
m := fmin(2.71, 3.14)
```

實例化 GMin[float64] 產生的實際上是我們原來的浮點 Min 函數，我們可以在函數呼叫中使用它。

型別參數也可以與型別一起使用。

```go
type Tree[T interface{}] struct {
    left, right *Tree[T]
    value T
}

func (t *Tree[T]) Lookup(x T) *Tree[T] { ... }

var stringTree Tree[string]
```

在這裡，泛型型別 Tree 儲存型別參數 T 的值。泛型型別可以有方法，例如此範例中的 Lookup。為了使用泛型型別，必須對其進行實例化；Tree[string] 是使用型別引數 string 實例化 Tree 的範例。

## 型別集

讓我們更深入地研究一下可以用來實例化型別參數的型別引數。

一個普通的函數對於每個值參數都有一個型別；該型別定義了一組值。例如，如果我們有一個 float64 型別，如上面的非泛型函數 Min，則引數值的可允許的集合，是可以由 float64 型別表示的浮點值集合。

同樣地，型別參數列表對於每個型別參數都有一個型別。因為型別參數本身就是一種型別，所以型別參數的型別定義了一組型別。這種元型別稱為型別約束。

在泛型 GMin 中，型別約束是從 [constraints 套件](https://pkg.go.dev/golang.org/x/exp/constraints)匯入。Ordered 約束描述了所有具有可排序值的型別集，換句話說，可使用 < 運算子（或 <=，> 等）進行比較。約束確保只有具有可排序值的型別才能傳遞給 GMin。這也意味著在 GMin 函數主體中，可以使用該型別參數的值與 < 運算子進行比較。

在 Go 中，型別約束必須是介面。也就是說，介面型別可以用作值型別，也可以用作元型別。介面定義方法，因此我們可以表達需要存在某些方法的型別約束。但是，constraints.Ordered 也是介面型別，< 運算子不是方法。

為了使其運作，我們以一種新的方式看待介面。

直到最近，Go 規格說介面定義了一組方法，這大致是介面中列舉的方法集。實作所有這些方法的任何型別都實作了該介面。

但是，從這個角度來看，介面定義了一組型別，即實作這些方法的型別。從這個角度來看，介面型別的值是介面型別集合的元素，而不是介面型別的實作。

這兩種觀點導致相同的結果：對於每組方法，我們都可以想像實作這些方法的型別的相應集合，並且這是介面定義的型別集。

但是，對於我們的目的來說，型別集的觀點比方法集的觀點更具優勢：我們可以明確地將型別添加到集合中，從而以新的方式控制型別集。

我們已經擴展了介面型別的語法，以使其運作。例如，interface{ int|string|bool } 定義了包含型別 int、string 和 bool 的型別集。

另一種說法是，此介面僅由 int、string 或 bool 滿足。

現在讓我們看一下 constraints.Ordered 的實際定義：

```go
type Ordered interface {
    Integer|Float|~string
}
```

此宣告表示 Ordered 介面是所有整數、浮點和字串型別的集合。垂直線表示型別的聯集（在這種情況下是型別集的聯集）。Integer 和 Float 是在 constraints 套件中以類似方式定義的介面型別。請注意，Ordered 介面沒有定義任何方法。

對於型別約束，我們通常不關心特定型別，例如 string；我們感興趣的是所有 string 型別。這就是 ~ 標記的用途。表達式 ~string 表示底層型別為 string 的所有型別的集合。這包括型別 string 本身以及使用定義 type MyString string 等定義宣告的所有型別。

當然，我們仍然希望在介面中指定方法，並且希望向後兼容。在 Go 1.18 中，介面可以像以前一樣包含方法和嵌入式介面，但是它也可以嵌入非介面型別、聯集和底層型別的集合。

當用作型別約束時，介面定義的型別集確切指定了允許作為相應型別參數的型別引數的型別。在泛型函數主體中，如果運算元（operand）的型別是帶有約束 C 的型別參數 P，則只有在 C 的型別集中的所有型別都允許操作時，才允許操作（目前在這裡有一些實作限制，但是普通程式碼不太可能遇到它們）。

用作約束的介面可以給定名稱（例如 Ordered），也可以是內嵌（inlined）在型別參數列表中的文字介面。例如：

```go
[S interface{~[]E}, E interface{}]
```

這裡 S 必須是切片型別，其元素型別可以是任何型別。

因為這是一個常見的情況，所以可以省略約束位置中的封閉介面 interface{}，我們可以簡單地寫成：

```go
[S ~[]E, E interface{}]
```

因為空介面在型別參數列表中很常見，而且在普通的 Go 程式碼中也很常見，所以 Go 1.18 引入了一個新的預先宣告的識別符號 any，作為空介面型別的別名。有了這個，我們就可以得到這個慣用的程式碼：

```go
[S ~[]E, E any]
```

介面作為型別集是一種強大的新機制，是使型別約束在 Go 中運作的關鍵。目前，使用新的語法形式的介面只能用作約束。但是很容易想像出明確的型別約束介面在一般情況下可能有用。

## 型別推論

## 參考來源

- [An Introduction To Generics](https://go.dev/blog/intro-generics)
